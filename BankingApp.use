-- This is a USE model of the Banking Application described in Using UML To Visualize Role-Based Access Control Constraints
-- By: Matthew Tuan and Robbie Dutton

model BankingApp

-- classes

class Session
operations
  AddActiveRole(r: Role)
  DropActiveRole(r: Role)
  CheckAccess(obj : Object, op : Operation) : Boolean =
      let directRoles   = self.e in
      let juniorRoles   = directRoles->collect(r | r.junior)->asSet() in
      let allRoles      = directRoles->union(juniorRoles) in
        allRoles->exists(r |
          r.l->exists(p |
            p.f->includes(obj) and
            p.p->includes(op)
          )
        )
  InvokeOperation(obj : Object, op : Operation)
end

class User
attributes
  UserId : String
operations
  CreateSession(s: Session)
  DeleteSession(s: Session)
  AssignRole(r: Role)
  DeassignRole(r: Role)
  AssignedRoles() : Set(Role)
  AuthorizedRoles() : Set(Role)
end

class Role 
attributes
  name : String
operations
  GrantPermission(p: Permission)
  RevokePermission(p: Permission)
  --- In this check access, we just want to make sure that this role, 
  --- and its descendants have at least one attached to the operation and object via a permission
  CheckAccess(obj : Object, op : Operation)  : Boolean =
  let rolesToCheck : Set(Role) = self.Descendants()->including(self) in
    rolesToCheck->exists(r |
      r.l->exists(p |
        p.f->includes(obj)
        and
        p.p->includes(op)
      )
    )
  AddAscendant(r: Role)
  DeleteAscendant(r: Role)
  AddDescendant(r: Role)
  DeleteDescendant(r: Role)
  AddSSDRole(r: Role)
  DeleteSSDRole(r: Role)
  AddDSDRole(r: Role)
  DeleteDSDRole(r: Role)
  AssignedUsers() : Set(User)
  AuthorizedUsers() : Set(User)
  Ascendants() : Set(Role)
  Descendants() : Set(Role) =
      let direct   = self.junior in
      let indirect = direct->collect(r | r.junior)->asSet() in
        direct->union(indirect)
    
  SSDRoles() : Set(Role)
  DSDRoles() : Set(Role)
end

class Permission
operations
  -- For this, we just want to make sure it is binded. So we check that the object and permission are both included.
  CheckAccess(obj : Object, op : Operation) : Boolean = 
    self.f->includes(obj)
      and
    self.p->includes(op) 
end

class Object
end

class Operation
end

-- associations

association UserSessions between
  User[1] role user
  Session[0..*] role a
end

association UserAssignment between
  User[0..*] role b
  Role[0..*] role c
end

association SessionRoles between
  Session[0..*] role d
  Role[0..*] role e
end

association PermAssignment between
  Role[0..*] role k
  Permission[0..*] role l
end

association PermObjects between
  Permission[0..*] role m
  Object[0..*] role f
end

association PermOperations between
  Permission[0..*] role n
  Operation[0..*] role p
end

association ExecuteOn between
  Object[0..*] role o
  Operation[0..*] role q
end

association SSD between
  Role[0..*] role g
  Role[0..*] role h
end

association DSD between
  Role[0..*] role r
  Role[0..*] role s
end

association RoleHierarchy between
  Role[0..*] role senior
  Role[0..*] role junior
end

-- constraints

constraints

-- class constraints



-- operation constraints

context User::CreateSession(s: Session)
  post createSessionPost: self.a -> includes(s)

context User::DeleteSession(s: Session)
  post deleteSessionPost: self.a -> excludes(s)

context Role::GrantPermission(p: Permission)
  pre grantPre: self.l -> excludes(p)
  post grantPost: self.l -> includes(p)

context User::AssignRole(r: Role)
  pre assignRolePre: self.c -> excludes(r)
  post assignRolePost: self.c -> includes(r)

context User::DeassignRole(r: Role)
  pre assignRolePre: self.c -> includes(r)
  post assignRolePost: self.c -> excludes(r)



-- class invariants

-- Basic SSD and DSD constraints

-- Static Separation of Duty (SSD): Conflicting roles cannot be assigned to the same user
context Role inv SSDConstraint:
  self.b->excludesAll(self.g.b)

-- Dynamic Separation of Duty (DSD): Conflicting roles cannot be activated in the same session
context Role inv DSDConstraint:
  self.d->excludesAll(self.s.d)




-- Active roles must be a subset of the user's assigned roles
context Session inv ActiveRolesSubsetOfUserRoles:
  self.e->forAll(r | self.user.c->includes(r))


-- Role hierarchy: a role inherits all permissions from its junior roles
context Role inv PermissionInheritance:
  self.junior->forAll(j | self.l->includesAll(j.l))
