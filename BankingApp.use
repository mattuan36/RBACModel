-- This is a USE model of the Banking Application described in Using UML To Visualize Role-Based Access Control Constraints
-- Part 3: Implementing Location to RBAC Model
-- By: Matthew Tuan and Robbie Dutton

model BankingApp

-- classes
class Location
attributes
  lat: Real
  long: Real
operations
end

class Session
operations
  AddActiveRole(r: Role)
  DropActiveRole(r: Role)
  CheckAccess(obj : Object, op : Operation) : Boolean =
    let u   = self.user,
        rs  = self.e,
        jrs = rs->collect(r | r.junior)->asSet(),
        all = rs->union(jrs)
    in
      all->exists(r |
        -- role is valid for the user's current location
        u.currentLocation = r.activeLocation and
        -- permission links + location constraints
        r.l->exists(p |
          p.f->includes(obj) and                  -- object allowed
          p.p->includes(op) and                   -- operation allowed
          p.lp->includes(u.currentLocation) and   -- user's location allowed by permission
          p.lpo->includes(obj.currentLocation)    -- object's location allowed by permission
        )
      )
  InvokeOperation(obj : Object, op : Operation)
end

class User
attributes
  UserId : String
operations
  CreateSession() : Session
  DeleteSession(s: Session)
  AssignRole(r: Role)
  DeassignRole(r: Role)
  AssignedRoles() : Set(Role)
  AuthorizedRoles() : Set(Role)
  AssignLocation(l: Location)
  DeleteLocation(l: Location)
  GetLocation(): Location
end

class Role 
attributes
  name : String
operations
  GrantPermission(p: Permission)
  RevokePermission(p: Permission)
  --- In this check access, we just want to make sure that this role, 
  --- and its descendants have at least one attached to the operation and object via a permission
  CheckAccess(obj : Object, op : Operation)  : Boolean =
  let rolesToCheck : Set(Role) = self.Descendants()->including(self) in
    rolesToCheck->exists(r |
      r.l->exists(p |
        p.f->includes(obj)
        and
        p.p->includes(op)
      )
    )
  AddAscendant(r: Role)
  DeleteAscendant(r: Role)
  AddDescendant(r: Role)
  DeleteDescendant(r: Role)
  AddSSDRole(r: Role)
  DeleteSSDRole(r: Role)
  AddDSDRole(r: Role)
  DeleteDSDRole(r: Role)
  AssignedUsers() : Set(User)
  AuthorizedUsers() : Set(User)
  Ascendants() : Set(Role)
  Descendants() : Set(Role) =
      let direct   = self.junior in
      let indirect = direct->collect(r | r.junior)->asSet() in
        direct->union(indirect)
    
  SSDRoles() : Set(Role)
  DSDRoles() : Set(Role)
  AssignLocation(l: Location)
  DeleteAssignLocation(l: Location)
  ActiveLocation(l: Location)
  DeleteActiveLocation(l: Location)
  GetAssignLocation() : Location
  GetActiveLocation() : Location
end

class Permission
operations
  -- For this, we just want to make sure it is binded. So we check that the object and permission are both included.
  CheckAccess(obj : Object, op : Operation) : Boolean = 
    self.f->includes(obj)
      and
    self.p->includes(op) 
end

class Object
operations
  AssignLocation(l: Location)
  DeleteLocation(l: Location)
  GetLocation(): Location
end

class Operation
end

-- associations

association UserSessions between
  User[1] role user
  Session[0..*] role a
end

association UserAssignment between
  User[0..*] role b
  Role[0..*] role c
end

association SessionRoles between
  Session[0..*] role d
  Role[0..*] role e
end

association PermAssignment between
  Role[0..*] role k
  Permission[0..*] role l
end

association PermObjects between
  Permission[0..*] role m
  Object[0..*] role f
end

association PermOperations between
  Permission[0..*] role n
  Operation[0..*] role p
end

association ExecuteOn between
  Object[1..*] role o
  Operation[1..*] role q
end

association SSD between
  Role[0..*] role g
  Role[0..*] role h
end

association DSD between
  Role[0..*] role r
  Role[0..*] role s
end

association RoleHierarchy between
  Role[0..*] role senior
  Role[0..*] role junior
end

association UserLocation between
  Location[1] role currentLocation
  User[0..*] role presentUsers
end

association ObjLocation between
  Location[1] role currentLocation
  Object[0..*] role presentObjects
end

association AssignLocation between
  Location[1] role assignLocation
  Role[0..*] role assignRole
end

association ActiveLocation between
  Location[1] role activeLocation
  Role[0..*] role activeRole
end

association PermRoleLoc between
  Location[0..*] role lp
  Permission[0..*] role pl
end

association PermObjLoc between
  Location[0..*] role lpo
  Permission[0..*] role plo
end

association SessionLocation between
  Location[1] role currentLocation
  Session[0..*] role sessions
end

-- constraints

constraints

-- class constraints



-- operation constraints

context User::CreateSession() : Session
  post sessionCreated: result.oclIsNew()
  post linkUserSession: self.a->includes(result)
  post sessionHasUserLoc: result.currentLocation = self.currentLocation

-- context User::CreateSession(): Session
--   post sessionCreated: result.oclIsNew() = true
--   post createSessionPost: self.a -> includes(result)

context User::DeleteSession(s: Session)
  post deleteSessionPost: self.a -> excludes(s)

context Role::GrantPermission(p: Permission)
  pre grantPre: self.l -> excludes(p)
  post grantPost: self.l -> includes(p)

context User::AssignRole(r: Role)
  pre assignRolePre: self.c -> excludes(r)
  pre assignLocationOK: self.currentLocation = r.assignLocation
  post assignRolePost: self.c -> includes(r)

context User::DeassignRole(r: Role)
  pre assignRolePre: self.c -> includes(r)
  post assignRolePost: self.c -> excludes(r)

-- Location Restricted Activation Hierarchy: Senior role can activate junior role (only if junior role can be activated based on location)

-- Ensure that the user is in the currentlocation where the role's activelocation is set.
context Session::AddActiveRole(r: Role)
  pre mustBeAssigned: self.user.c->includes(r)
  pre locationOK:     self.user.currentLocation = r.activeLocation
  pre noDSDConflict:  self.e->intersection(r.s)->isEmpty()


-- class invariants

-- Basic SSD and DSD constraints

-- Static Separation of Duty (SSD): Conflicting roles cannot be assigned to the same user
context Role inv SSDConstraint:
  self.b->excludesAll(self.g.b) and self.b.currentLocation->excludesAll(self.g.assignLocation)

-- Dynamic Separation of Duty (DSD): Conflicting roles cannot be activated in the same session
context Role inv DSDConstraint:
  self.d->excludesAll(self.s.d) and r.g.activeLocation->excludesAll(r.activeLocation)

-- Active roles must be a subset of the user's assigned roles
context Session inv ActiveRolesSubsetOfUserRoles:
  self.e->forAll(r | self.user.c->includes(r))

-- Location Restricted Permission Inheritance Hierarchy: Senior role inherits junior role permissions (restricted to the locations imposed on the junior roles)
context Role inv PermissionInheritance:
  self.junior->forAll(j | self.l->includesAll(j.l)) and
  self.junior->forAll(j | self.l.lp->includesAll(j.l.lp))
  -- OLD self.junior->forAll(j | self.l->includesAll(j.l))

context User inv UserHasOneLocation:
  self.currentLocation->size()=1

context Object inv ObjectHasOneLocation:
  self.currentLocation->size()=1

context Role inv AssignHasOneLocation:
  self.assignLocation->size()=1

context Role inv ActiveHasOneLocation:
  self.activeLocation->size()=1


