-- This is a USE model of the Banking Application described in Using UML To Visualize Role-Based Access Control Constraints
-- By: Matthew Tuan and Robbie Dutton

model BankingApp

-- classes

class Session
operations
  AddActiveRole(r: Role)
  DropActiveRole(r: Role)
  CheckAccess(obj : Object, op : Operation)  : Boolean
  InvokeOperation(obj : Object, op : Operation)
end

class User
attributes
  UserId : String
operations
  CreateSession(s: Session)
  DeleteSession(s: Session)
  AssignRole(r: Role)
  DeassignRole(r: Role)
  AssignedRoles() : Set(Role)
  AuthorizedRoles() : Set(Role)
end

class Role 
attributes
  name : String
operations
  GrantPermission(p: Permission)
  RevokePermission(p: Permission)
  CheckAccess(obj : Object, op : Operation)  : Boolean
  begin
    --- code here
  end
  AddAscendant(r: Role)
  DeleteAscendant(r: Role)
  AddDescendant(r: Role)
  DeleteDescendant(r: Role)
  AddSSDRole(r: Role)
  DeleteSSDRole(r: Role)
  AddDSDRole(r: Role)
  DeleteDSDRole(r: Role)
  AssignedUsers() : Set(User)
  AuthorizedUsers() : Set(User)
  Ascendants() : Set(Role)
  Descendants() : Set(Role)
  SSDRoles() : Set(Role)
  DSDRoles() : Set(Role)
end

class Permission
operations
  CheckAccess(obj : Object, op : Operation) : Boolean
end

class Object
end

class Operation
end

-- associations

association UserSessions between
  User[1] role user
  Session[0..*] role a
end

association UserAssignment between
  User[0..*] role b
  Role[0..*] role c
end

association SessionRoles between
  Session[0..*] role d
  Role[0..*] role e
end

association PermAssignment between
  Role[0..*] role k
  Permission[0..*] role l
end

association PermObjects between
  Permission[0..*] role m
  Object[0..*] role f
end

association PermOperations between
  Permission[0..*] role n
  Operation[0..*] role p
end

association ExecuteOn between
  Object[0..*] role o
  Operation[0..*] role q
end

association SSD between
  Role[0..*] role g
  Role[0..*] role h
end

association DSD between
  Role[0..*] role r
  Role[0..*] role s
end

association RoleHierarchy between
  Role[0..*] role senior
  Role[0..*] role junior
end

-- constraints

constraints

-- class constraints



-- operation constraints

context User::CreateSession(s: Session)
  post createSessionPost: self.a -> includes(s)

context User::DeleteSession(s: Session)
  post deleteSessionPost: self.a -> excludes(s)

context Role::GrantPermission(p: Permission)
  pre grantPre: self.l -> excludes(p)
  post grantPost: self.l -> includes(p)

context User::AssignRole(r: Role)
  pre assignRolePre: self.c -> excludes(r)
  post assignRolePost: self.c -> includes(r)

context User::DeassignRole(r: Role)
  pre assignRolePre: self.c -> includes(r)
  post assignRolePost: self.c -> excludes(r)



-- class invariants

-- Basic SSD and DSD constraints

-- Static Separation of Duty (SSD): Conflicting roles cannot be assigned to the same user
context Role inv SSDConstraint:
  self.b->excludesAll(self.g.b)

-- Dynamic Separation of Duty (DSD): Conflicting roles cannot be activated in the same session
context Role inv DSDConstraint:
  self.d->excludesAll(self.s.d)







----- BELOW HERE IS SOMETHING BUT NOT SURE YET

-- Do these four even need to be implemented? We don't have a concept of prerequisites

-- SSD-Permission constraint: Conflicting permissions cannot be assigned to the same role.
-- context Role inv SSDPermissionConstraint:
--  self.l -> excludesAll(self.g.l)


-- Prerequisite-Role constraint: A user can be assigned to a role only if the user is already assigned to the roleâ€™s prerequisites.
-- context User inv PrerequisiteRole:
--   self.c -> includesAll(self.c.h)

-- SSD-User constraint: Conflicting users cannot be assigned to the same role.
-- context User inv SSDUserConstraint:
--   u1.Role -> excludesAll(u2.Role)

-- Prerequisite-Permission constraint: A permission can be assigned to a role only if the role already possesses the permission's prerequisites.
-- context Role inv PrerequisitePerm:
--  self.l -> includesAll(self.h.l)




-- Active roles must be a subset of the user's assigned roles
context Session inv ActiveRolesSubsetOfUserRoles:
  self.e->forAll(r | self.user.c->includes(r))


-- Role hierarchy: a role inherits all permissions from its junior roles
context Role inv PermissionInheritance:
  self.junior->forAll(j | self.l->includesAll(j.l))


-- This one is not working :(
-- Simulated CheckAccess: A session should have access to at least one operation on one object
-- if any of its active roles (or their juniors) has such permission
--context Session inv HasAtLeastOneValidAccess:
--  self.e->closure(junior)->exists(r |
--    r.l->exists(p |
--      p.f->exists(o | p.p->exists(op | o.q->includes(op)))
--    )
--  )